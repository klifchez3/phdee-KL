# phd-ee homework 2 - python script for kwh analysis
# kelly lifchez
# 01/20/2025

# import libraries 
import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
import scipy.stats as sc

# Set working directories and seed

inputpath = r'/Users/kellylifchez/GaTech Dropbox/Kelly Lifchez/phdee-KL/homework2/data/raw'
outputpath = r'/Users/kellylifchez/GaTech Dropbox/Kelly Lifchez/phdee-KL/homework2/output'

#setting same seed as homework 1 for consistency 
np.random.seed(6578103)

# Load data - read in the kwh.csv file
df = pd.read_csv(os.path.join(inputpath, 'kwh.csv'))


### Question 1 - Balance Table

## set up 

# assign control and treatment groups  
control_group = df[df['retrofit'] == 0]
treatment_group = df[df['retrofit'] == 1.0]
# note: this ^ is one option - can also specify py equivalent of "if retrofit = 0" in the next steps

# store variable names (besides retrofit)
varlist = ['electricity', 'sqft', 'temp']

## means and standard deviations for each variable and treatment group
control_mean = df[ df[ 'retrofit' ] == 0 ].mean().drop('retrofit')
treatment_mean = df[ df[ 'retrofit' ] == 1 ].mean().drop('retrofit')

control_std = df[ df[ 'retrofit' ] == 0 ].std().drop('retrofit')
treatment_std = df[ df[ 'retrofit' ] == 1 ].std().drop('retrofit')

# difference in means / two-way t test
t_stat, p_val = sc.ttest_ind(df[df['retrofit'] == 0].drop('retrofit', axis=1), df[df['retrofit'] == 1].drop('retrofit', axis=1), equal_var=False)
p_val = pd.Series(p_val, index=df.columns.drop('retrofit'))

#tval, pval = sc.ttest_ind(df[ df[ 'retrofit' ] == 0 ].drop('retrofit',1) , df[ df[ 'retrofit' ] == 1 ].drop('retrofit',1) , equal_var = False)
#t_stat, p_val = stats.ttest_ind(df[ df[ 'retrofit' ] == 0 ].drop('retrofit',1) , df[ df[ 'retrofit' ] == 1 ].drop('retrofit',1) , equal_var = False)
# p_val = pd.Series(p_val,varlist)


## table prep!

# get number of observations 
nobs_control = pd.Series(df[ df[ 'retrofit' ] == 0 ].count().min()) #min is smallest count of non-null values across all vars for control group
nobs_treatment = pd.Series(df[ df[ 'retrofit' ] == 1 ].count().min())
nobs_total = pd.Series(df.count().min())

# display observations as integers
nobs_control = nobs_control.map('{:.0f}'.format)
nobs_treatment = nobs_treatment.map('{:.0f}'.format)
nobs_total = nobs_total.map('{:.0f}'.format)

# display means, standard deviations, and p-values to two decimal places

control_mean = control_mean.map('{:.2f}'.format)
treatment_mean = treatment_mean.map('{:.2f}'.format)
control_std = control_std.map('({:.2f})'.format)
treatment_std = treatment_std.map('({:.2f})'.format)
p_val = p_val.map('{:.2f}'.format)


# set up rows and columns
rowlist = varlist + ['Observations']

# rows: stack empty list for stdevs and capitalize varnames
rownames = pd.concat([pd.Series(x.capitalize() for x in rowlist),pd.Series([' ',' ',' '])],axis = 1).stack()
# columns: make two levels of column names
columnnames = [('Control','(s.d.)'),('Treatment','(s.d.)'),('P-Value',' ')] 

# stack std deviations under means
col0 = pd.concat([control_mean,control_std,nobs_control],axis = 1,keys = ['mean','std dev','obs']).stack()

col1 = pd.concat([treatment_mean,treatment_std,nobs_treatment],axis = 1,keys = ['mean','std dev','obs']).stack()

# create empty list of standard deviations for p-value columm
empty_std_list = [''] * len(p_val)

# Combine p-values with the empty standard deviations and number of observations
col2 = pd.concat([p_val, pd.Series(empty_std_list, index=p_val.index), nobs_total], axis=1, keys=['p value', 'std dev', 'obs']).stack()

#col2 = pd.concat([p_val,nobs_total],axis = 1,keys = ['p value',' ','obs']).stack()

# remove Pandas indices
col0 = col0.reset_index(drop = True)
col1 = col1.reset_index(drop = True)
col2 = col2.reset_index(drop = True)

# combine columns to create table

balancetable = pd.concat([col0,col1,col2],axis = 1)
balancetable.columns = pd.MultiIndex.from_tuples(columnnames)
balancetable.index = rownames

print(balancetable)
print(balancetable.to_latex())

# Output directly to LaTeX folder
os.chdir(outputpath) 
balancetable.to_latex('py_balancetable.tex')


############################################################################################################
# Plot a histogram of the outcome variable -----------------------------------
sns.displot(yvar,kind='kde',legend = False)
plt.xlabel('Outcome variable')
plt.legend(labels = ['Distribution of outcome variable'],loc = 'best',bbox_to_anchor = (0.75,-0.1))
plt.savefig('samplehist.pdf',format='pdf') # I suggest saving to .pdf for highest quality
plt.show()

### Question 2 
# Plot a histogram of the outcome variable -----------------------------------
sns.displot(yvar,kind='kde',legend = False)
plt.xlabel('Outcome variable')
plt.legend(labels = ['Distribution of outcome variable'],loc = 'best',bbox_to_anchor = (0.75,-0.1))
plt.savefig('samplehist.pdf',format='pdf') # I suggest saving to .pdf for highest quality
plt.show()
sns.distplot(kwh[ kwh[ 'retrofit' ] == 0 ]['electricity'], hist=False, label='Did not receive retrofit')
sns.distplot(kwh[ kwh[ 'retrofit' ] == 1 ]['electricity'], hist=False, label='Received retrofit')
plt.xlabel('Electricity use (KwH)')
plt.savefig('treatmenthist.pdf',format='pdf') # I suggest saving to .pdf for highest quality
plt.show()

### Question 3

## Part (a)
### Set up Numpy matrices for OLS:
Yvar = kwh['electricity'].to_numpy()
nobsa, = Yvar.shape
constant = np.ones((nobsa,1)) # Vector of ones for the constant
Xvar = kwh.drop('electricity',axis = 1).to_numpy()
Xvar = np.concatenate([constant,Xvar],axis = 1) # Add the constant

### Run the regression
betaolsa = np.matmul(np.linalg.inv((np.matmul(Xvar.T, Xvar))), np.matmul(Xvar.T, Yvar))

## Part (b)
### Set up objective function

def my_leastsq(beta,Y,X):
    return np.sum((Y-np.matmul(X,beta))**2)

### Set up the solver
betaolsb = opt.minimize(my_leastsq,np.array([0,1,1,1]).T, args = (Yvar, Xvar)).x # I had to play with the initial conditions to get it to converge
nobsb, = Yvar.shape

## Part (c)
### Simply call the statsmodels function.  Now there is an (arguably) easier way to do this using R-style syntax with an equation.
olsc = sm.OLS(kwh['electricity'],Xvar).fit()
betaolsc = olsc.params.to_numpy()
nobsc = olsc.nobs

## Output table

### Row and column names
xvarlist = ['Constant', 'Sqft', 'Retrofit', 'Temperature','Observations']

rownames3 = pd.Series(xvarlist)
colnames3 = pd.Series(['(a)','(b)','(c)'])

### Put outputs and observations together
outputtable3 = pd.DataFrame((np.append(betaolsa,nobsa),np.append(betaolsb,nobsb),np.append(betaolsc,nobsc))).T
outputtable3.index = rownames3
outputtable3.columns = colnames3

outputtable3 = outputtable3.reindex(index = ['Retrofit', 'Sqft', 'Temperature', 'Constant','Observations'])

### Format to three decimal places and change order
for z in colnames3 :
    outputtable3[z] = outputtable3[z].map('{:.3f}'.format)
    outputtable3.loc['Observations',z] = "{0:.0f}".format(float(outputtable3.loc['Observations',z])) # This cannot be the most efficient or elegant way to do this.

outputtable3.to_latex('outputtable3.tex')